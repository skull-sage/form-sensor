# Requirements Document

## Introduction

The Semantic Description Sensor is a full-stack application that uses sentence transformers to detect semantic similarity between text descriptions. The system acts as a metaphorical "sensor" that detects whether provided text descriptions match predefined descriptions contextually using the all-MiniLM-L6-v2 model. This enables applications like content moderation, FAQ matching, document classification, and duplicate detection.

## Glossary

- **Semantic_Sensor**: The core system that processes text descriptions and determines semantic similarity
- **Sentence_Transformer**: The all-MiniLM-L6-v2 model used for generating text embeddings
- **Predefined_Description**: Reference text descriptions stored in the system for comparison
- **Similarity_Score**: A numerical value (0-1) representing how semantically similar two text descriptions are
- **Similarity_Threshold**: A configurable minimum similarity score required for a match
- **Text_Embedding**: Vector representation of text generated by the sentence transformer model
- **Cosine_Similarity**: Mathematical method used to calculate similarity between text embeddings
- **Text_Sensor**: A collection of paragraphs mapped to a specific nameId for semantic comparison
- **NameId**: Unique identifier for a text sensor containing multiple paragraph descriptions
- **Paragraph_Splitting**: Process of dividing multi-paragraph text into individual paragraph descriptions

## Requirements

### Requirement 1

**User Story:** As a system administrator, I want to create text sensors from multi-paragraph text, so that I can establish reference libraries for semantic comparison.

#### Acceptance Criteria

1. WHEN an administrator calls POST /create-text-sensor/:nameId with {"text": "variable number of paragraphs separated by newlines"}, THE Semantic_Sensor SHALL split the text by newlines into individual paragraphs
2. WHEN text is split into paragraphs, THE Semantic_Sensor SHALL create a mapping where key is nameId and value is an array of paragraphs regardless of the number of paragraphs
3. WHEN paragraphs are stored, THE Semantic_Sensor SHALL generate embeddings for each paragraph using the all-MiniLM-L6-v2 model
4. WHEN embeddings are generated, THE Semantic_Sensor SHALL maintain a parallel mapping where key is nameId and value is an array of embeddings corresponding to each paragraph
5. WHEN a nameId already exists, THE Semantic_Sensor SHALL replace both the paragraph mapping and embedding mapping with new data

### Requirement 2

**User Story:** As a user, I want to check semantic similarity against a specific text sensor, so that I can determine if my text matches any stored paragraphs.

#### Acceptance Criteria

1. WHEN a user calls POST /text-sensor/:nameId with {"text": "a description"}, THE Semantic_Sensor SHALL generate an embedding for the input text using all-MiniLM-L6-v2
2. WHEN calculating similarity, THE Semantic_Sensor SHALL compare the input text embedding against all paragraph embeddings stored under the specified nameId
3. WHEN similarity scores are calculated, THE Semantic_Sensor SHALL use cosine similarity between the input embedding and each paragraph embedding
4. WHEN similarity scores are calculated, THE Semantic_Sensor SHALL return {"confidence_score": score} with the highest similarity score regardless of threshold

### Requirement 3

**User Story:** As a system operator, I want consistent similarity threshold behavior, so that text sensor matching is predictable and reliable.

#### Acceptance Criteria

1. WHEN checking text similarity, THE Semantic_Sensor SHALL use a fixed threshold of 0.6 for determining matches
2. WHEN similarity scores are >= 0.6, THE Semantic_Sensor SHALL consider the text as matching and return the confidence score
3. WHEN similarity scores are < 0.6, THE Semantic_Sensor SHALL still return the actual confidence score for frontend guidance
4. WHEN multiple paragraphs exceed the 0.6 threshold, THE Semantic_Sensor SHALL return the highest confidence score among all matches
5. WHEN calculating confidence scores, THE Semantic_Sensor SHALL return the actual cosine similarity value (not a boolean)

### Requirement 4

**User Story:** As a developer, I want specific RESTful API endpoints for text sensor operations, so that I can integrate semantic similarity checking into other applications.

#### Acceptance Criteria

1. WHEN the API receives a GET request to the root endpoint, THE Semantic_Sensor SHALL return a health check response
2. WHEN the API receives a POST request to /create-text-sensor/:nameId, THE Semantic_Sensor SHALL process the text and create paragraph-based sensors
3. WHEN the API receives a POST request to /text-sensor/:nameId, THE Semantic_Sensor SHALL check similarity against the specified sensor
4. WHEN the API receives a GET request to /text-sensors, THE Semantic_Sensor SHALL return all available text sensor nameIds
5. WHEN the API receives a DELETE request to /text-sensor/:nameId, THE Semantic_Sensor SHALL remove the specified text sensor

### Requirement 5

**User Story:** As a user, I want a web interface to interact with the semantic sensor, so that I can easily manage descriptions and check similarities without using API directly.

#### Acceptance Criteria

1. WHEN a user accesses the web interface, THE Semantic_Sensor SHALL display forms for adding descriptions and checking similarity
2. WHEN a user adds a description through the interface, THE Semantic_Sensor SHALL validate input and provide visual feedback
3. WHEN a user submits text for similarity checking, THE Semantic_Sensor SHALL display results with similarity percentages and color coding
4. WHEN similarity results are displayed, THE Semantic_Sensor SHALL highlight the best match and show all matches above threshold
5. WHEN a user adjusts the similarity threshold, THE Semantic_Sensor SHALL update the interface to reflect the new threshold value

### Requirement 6

**User Story:** As a system operator, I want proper error handling and validation, so that the system provides clear feedback and maintains stability.

#### Acceptance Criteria

1. WHEN invalid input is provided, THE Semantic_Sensor SHALL return descriptive error messages with HTTP status codes
2. WHEN the sentence transformer model fails to load, THE Semantic_Sensor SHALL return a service unavailable error
3. WHEN network requests fail, THE Semantic_Sensor SHALL provide appropriate timeout and retry mechanisms
4. WHEN empty or malformed text is submitted, THE Semantic_Sensor SHALL validate input and return specific error messages
5. WHEN system resources are insufficient, THE Semantic_Sensor SHALL handle gracefully and return resource limitation errors

### Requirement 7

**User Story:** As a developer, I want proper CORS configuration, so that the frontend can communicate with the backend API from different origins.

#### Acceptance Criteria

1. WHEN the frontend makes requests from localhost:9000, THE Semantic_Sensor SHALL accept and process the requests
2. WHEN preflight OPTIONS requests are made, THE Semantic_Sensor SHALL respond with appropriate CORS headers
3. WHEN credentials are included in requests, THE Semantic_Sensor SHALL handle them according to CORS policy
4. WHEN unauthorized origins attempt access, THE Semantic_Sensor SHALL reject requests with appropriate error responses
5. WHEN API responses are sent, THE Semantic_Sensor SHALL include necessary CORS headers for browser compatibility